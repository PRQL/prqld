package main

import (
  //"fmt"
  "strings"
  "strconv"
  "io/ioutil"

  log "github.com/sirupsen/logrus"
)


type TokenEntry struct {
  user string
  password string
  dbname string
  domains []string
  living bool
}

var (
  TokenPool = make(map[string]TokenEntry)
)


/**
* Token File Entry Schema
*
* token:username:password:dbname:domains:living
*
* token - 32-character string generated by the cli. Used to identify credentials 
*         and passed to the program from the client in the X-PrQL-Token header.
*
* username - The database username.
* 
* password - The database user's password.
* 
* dbname - The name of the database to create the connection to.
*
* domains - A comma separated list of authorized origins that this entry's token can
*           be used with. If left empty, then all origins are authorized.
*
* living - A boolean which indicates whether this entry will spawn a lifelong connection
*          to the specified database whenever the system starts up.
*/

func PopulateTokenPool() {
  buf, err := ioutil.ReadFile("/var/lib/prql/tokens")
  if err != nil {
    log.Fatal(err) 
  }

  entries := strings.Split(string(buf), "\n")
  if entries[len(entries) - 1] == "" {
    entries = entries[:len(entries) - 1] 
  }

  for i, entry := range entries {
    parts := strings.Split(entry, ":")  

    if len(parts) != 6 {
      log.Error("Invalid token entry at line " + strconv.Itoa(i + 1)) 
    }

    domains := strings.Split(parts[4], ",")
    living, err := strconv.ParseBool(parts[5])

    if err != nil {
      living = false 
    }

    TokenPool[parts[0]] = TokenEntry{
      user: parts[1], 
      password: parts[2], 
      dbname: parts[3], 
      domains: domains, 
      living: living,
    }
  }
}
